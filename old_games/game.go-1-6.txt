package cribbage

import (
	"fmt"
	"slices"
	"strings"
)

func (h Hand) Choose(k int) []Hand {
	var result []Hand
	var helper func(start int, current Hand)

	helper = func(start int, current Hand) {
		if len(current) == k {
			// use a copy to avoid aliasing
			hh := make(Hand, k)
			copy(hh, current)
			result = append(result, hh)
			return
		}
		// 0..2, {}
		// 1..1, {h[0]}
		for i := start; i <= len(h)-(k-len(current)); i++ {
			// 2 - len(current)
			helper(i+1, append(current, h[i]))
		}
	}

	helper(0, Hand{})
	return result
}

// Set Difference between a Hand6 and Hand4
func difference(full, subset Hand) Hand {
	marked := make(map[Card]int)
	// mark all cards in the subset (player's keep pile)
	for _, card := range subset {
		marked[card]++
	}

	// compare to all cards in the original (player's dealt hand)
	var diff Hand
	for _, card := range full {
		if marked[card] > 0 {
			marked[card]--
		} else {
			diff = append(diff, card)
		}
	}
	return diff
}

// ------------------------------------------------------------ //

type DiscardOption struct {
	Keep    Hand
	Discard Hand
	//ExpectedValue float64
}

// generate all ways to keep 4 and discard 2 at each round
func (hand Hand) Split(out int) []DiscardOption {
	in := len(hand)
	if in != 6 {
		fmt.Printf("Not a dealt hand of 6 cards!")
		return nil
	}
	if out != 4 {
		fmt.Printf("Cribbage hand must be 4 cards!")
		return nil
	}

	var options []DiscardOption
	keepList := hand.Choose(out)
	// check each subslice (keep pile) from 6 choose 4 on the Hand
	for _, keep := range keepList {
		// figure out the 2 discarded cards
		discard := difference(hand, keep)
		// Expected Value of 0 is unused
		// It is ignored or separately set by the caller of Split
		options = append(options, DiscardOption{keep, discard})
	}

	return options
}

func (opt DiscardOption) ExpectedValue(isDealer bool) float64 {
	// Hand and Deck are []Card
	var sumPoints int = 0
	var minimumCrib int = 0
	knownRemaining := difference(Hand(NewDeck()), append(opt.Keep, opt.Discard...))

	// For every possible cut card, the Player would get that score during Show
	for _, cut := range knownRemaining {
		// Score during Show, crib is false
		sumPoints += opt.Keep.Score(cut, false)
	}
	// Expected Points is the average of Show points from every possible cut card
	// Anything in our Keep / Discard is not a cut, and we do not know the opponent's hand
	count := float64(len(knownRemaining)) // 46
	expectedShow := float64(sumPoints) / count

	// TODO assuming that best Show points is the best Keep/Discard is WRONG

	// if isDealer we count some points from discard
	if isDealer {
		// Score during Show with Crib (only 2 cards known)
		// 52 choose 2 is 1326, 46... is 1035
		minimumCrib += opt.Discard.HeuristicScore()
	} else {
		minimumCrib -= opt.Discard.HeuristicScore()
	}

	// TODO model opponent
	// avoid sum (sometimes?) to 5, 10, 21

	return expectedShow + float64(minimumCrib)
}

func (hand Hand) ExpectedValue(isCrib bool) float64 {
	var remaining []Card
	// difference of hand and Deck (keep+discard)
	// 45 cards and 1 cut

	// TODO add argument for opponent's hand?

	total := 0
	for _, cut := range remaining {
		total += hand.Score(cut, isCrib)
	}
	return float64(total) / float64(len(remaining))
}

/*
func expectedValue(h Hand) {

}

	func (h Hand) analyzeDiscard() (Card, Card) {
		// foreach in h.Choose, keep track of what was discarded
		// and its resulting expected points
		// expected points is by Score with each possible cut
		// placeholder
		return h[0], h[1]
	}
*/

/*func (h Hand) AnalyzeDiscards(deck []Card, isCrib bool) []DiscardResult {
	results := []DiscardResult{}

	for _, keep := range h.Choose(4) {
		discard := difference(h, keep)
		used := append(h, discard...)
		remaining := RemainingDeck(deck, used)

		ev := ExpectedValue(keep, remaining, isCrib)

		results = append(results, DiscardResult{
			Keep:    keep,
			Discard: discard,
			ExpectedValue:      ev,
		})
	}

	return results
}
*/

func ExpectedValue(keep Hand, remaining []Card, isCrib bool) float64 {
	total := 0
	for _, cut := range remaining {
		total += keep.Score(cut, isCrib)
	}
	return float64(total) / float64(len(remaining))
}

// ------------------------------------------------------------ //

type Player interface {
	// 2 discard and 4 in hand
	Discard(isDealer bool) (Hand, Hand)
	PlayPegCard(state PegState) (Card, bool)
	String() string
	GetName() string
	GetHand() Hand
	SetHand(h Hand)
	AddPoints(n int) int
	GetScore() int
}

type ComputerPlayer struct {
	Name    string
	Hand    Hand
	PegHand Hand
	Points  int
}

func (p *ComputerPlayer) String() string {
	return p.Name
}

func (p *ComputerPlayer) GetName() string {
	return p.Name
}

func (p *ComputerPlayer) GetScore() int {
	return p.Points
}

func (p *ComputerPlayer) GetHand() Hand {
	return p.Hand
}

func (p *ComputerPlayer) SetHand(h Hand) {
	p.Hand = h
}

func (game *Game) AddPoints(i, amount int) bool {
	total := game.Players[i].AddPoints(amount)
	if total >= 121 {
		game.GameWon = true
		// do not continue the Cribbage round (unused)
		return false
	}
	return true
}

func (p *ComputerPlayer) AddPoints(n int) int {
	p.Points += n
	return p.Points
}

func (p *ComputerPlayer) Discard(isDealer bool) (discard Hand, keep Hand) {
	Options := p.Hand.Split(4)
	var bestOption DiscardOption = Options[0]
	var bestEV float64 = 0.0

	// every possible Keep/Discard and their average score
	for _, option := range Options {
		// TODO isCribOwner
		ev := option.ExpectedValue(isDealer)
		if ev > bestEV {
			bestEV = ev
			bestOption = option
		}
	}
	discard = bestOption.Discard
	keep = bestOption.Keep

	p.Hand = keep
	// copy of Hand will be emptied during Pegging
	p.PegHand = make(Hand, len(keep))
	copy(p.PegHand, keep)
	return

	/*
		h := p.Hand
		discard = h[:2]
		keep = h[2:]

		p.Hand = keep
		p.PegHand = make(Hand, len(keep))
		copy(p.PegHand, keep)
		return
	*/
}

func (p *ComputerPlayer) PeggingHeuristic(s PegState) Card {
	// For every playable card in Hand...
	// Immediate gain
	// Target 15, 31, pair, run

	// Subtract risk score (enables opponent points)
	// Avoid 5, 10, 21, opponent run

	// Predictive reasoning
	// Allow a card if optimal opponent behavior can be used
	// e.g. play 7, expect 8, play 9 (+3 run > +2 15 for opponent)

	// Position from 15 or 31
	// Force opponent GO

	return Card{}
}

func (p *ComputerPlayer) PlayPegCard(s PegState) (c Card, passed bool) {
	// send first valid card in Player's hand
	// TODO: consider run, in a row, 15, 31, ?predict other player?
	for i, card := range p.PegHand {
		if card.ValueMax10() <= 31-s.Sum {
			p.PegHand = slices.Delete(p.PegHand, i, i+1)
			return card, false
		}
	}
	// no valid card, Go/pass
	return Card{}, true
}

// ------------------------------------------------------------ //

type Game struct {
	Deck    Deck
	Players [2]Player
	Dealer  int
	GameWon bool
}

func (g *Game) StartGame() {
	roundNum := 0
	//for g.Players[0].GetScore() < 121 && g.Players[1].GetScore() < 121 {
	for !g.GameWon {
		fmt.Printf("--- Round #%d ---\n", roundNum+1)
		g.PlayRound()
		g.Dealer = 1 - g.Dealer
		roundNum++
	}
}

/*func (game *Game) PrintShowPoints(i int, points ScoreBreakdown) {
	player := game.Players[i]
	fmt.Printf("%s: %d points\n", player.GetName(), points.Total)
	points.Print()
}
*/

/*func (g *Game) AddShowPoints(ponePoints, dealPoints ScoreBreakdown) (gameOver bool, winner int) {
	pone := 1 - g.Dealer
	dealer := g.Dealer

	fmt.Printf("%s: %d points\n", g.Players[pone].GetName(), ponePoints.Total)
	ponePoints.Print()
	/*total := g.Players[pone].AddPoints(ponePoints.Total)
	if total >= 121 {
		//fmt.Printf("%s won!\n", Players[pone].GetName())
		return true, pone
	}* /
	g.AddPoints(pone, ponePoints.Total)
	if g.GameWon {
		return true, pone
	}

	fmt.Printf("%s: %d points\n", g.Players[dealer].GetName(), dealPoints.Total)
	dealPoints.Print()
	g.AddPoints(dealer, dealPoints.Total)
	if g.GameWon {
		return true, dealer
	}

	return false, 0
}
*/

// Print total points with some message/header
func (g *Game) PrintPoints(msg string, previous0 int, previous1 int) {
	previous := [2]int{previous0, previous1}
	msg = fmt.Sprintf("--- %s ---", msg)

	fmt.Println(msg)
	for i, player := range g.Players {
		currentPoints := g.Players[i].GetScore()
		// Player name, points increased, total points
		fmt.Printf("%s (+%d)", player, currentPoints-previous[i])
		fmt.Printf(" : %d points\n", currentPoints)
	}
	fmt.Printf("%s\n", strings.Repeat("-", len(msg)))
}

func (game *Game) CelebrateWinner(winner int) {
	Loser := game.Players[1-winner]
	Winner := game.Players[winner]
	diff := Winner.GetScore() - Loser.GetScore()

	msg := fmt.Sprintf("--- %s won ---", Winner.GetName())
	fmt.Printf("\n%s\n", msg)
	for i, player := range game.Players {
		currentPoints := game.Players[i].GetScore()
		fmt.Printf("%s: %d points\n", player.GetName(), currentPoints)
	}
	fmt.Println(strings.Repeat("-", len(msg)))

	if diff > 60 {
		fmt.Println("DOUBLE SKUNK")
	} else if diff > 30 {
		fmt.Println("SKUNK")
	}
	fmt.Printf("Good Game %s!\n", Loser.GetName())
}

func (game *Game) PlayRound() {
	// Simulate shuffle and card deal
	game.Deck.Shuffle()
	hand1, hand2, remainingDeck := Deal(game.Deck, 6)
	game.Players[0].SetHand(hand1)
	game.Players[1].SetHand(hand2)
	//ShowCardDeal(game.Players[0], game.Players[1])
	crib := Hand{}
	pone := 1 - game.Dealer
	dealer := game.Dealer

	// Discard to form Crib
	for i, player := range game.Players {
		isDealer := i == dealer
		discard, _ := player.Discard(isDealer)
		//fmt.Println(keep)
		crib = append(crib, discard...)
	}

	// Cut card from top of deck
	cut := remainingDeck[0]
	fmt.Printf("Cut Card: %s\n", cut)
	if cut.Rank == Jack {
		fmt.Printf("%s scores +2 [Nibs]\n", game.Players[dealer])
		game.AddPoints(dealer, 2)
		if game.GameWon {
			game.CelebrateWinner(dealer)
			return
		}
	}

	// Player's place one card at a time onto a pile and score points
	// New pile after cards add to 31 points, until both Hands are empty
	title := "--- PEGGING ---"
	fmt.Printf("\n%s\n", title)
	fmt.Printf("Dealer: %s\nPone leads\n", game.Players[dealer])
	fmt.Printf("%s\n\n", strings.Repeat("-", len(title)))

	before0 := game.Players[0].GetScore()
	before1 := game.Players[1].GetScore()
	//game.StartPegging()
	if game.GameWon {
		// CelebrateWinner inside StartPegging
		return
	}
	fmt.Println()
	game.PrintPoints("SUMMARY (PLAY)", before0, before1)

	// Score Hands: Pone will count points first
	fmt.Printf("\n--- COUNTING ---\n")
	fmt.Printf("Cut Card: %s\n", cut)
	before0 = game.Players[0].GetScore()
	before1 = game.Players[1].GetScore()

	// Score pone's hand
	ponePlayer := game.Players[pone]
	poneHand := ponePlayer.GetHand()
	ponePoints := poneHand.ScoreBreakdown(cut, false)
	fmt.Printf("%s: %s", ponePlayer.GetName(), poneHand)
	fmt.Printf(" (%d points)\n", ponePoints.Total)
	ponePoints.Print()

	game.AddPoints(pone, ponePoints.Total)
	if game.GameWon {
		game.CelebrateWinner(pone)
		return
	}

	// Score dealer's hand
	dealPlayer := game.Players[dealer]
	dealerHand := dealPlayer.GetHand()
	dealerPoints := dealerHand.ScoreBreakdown(cut, false)
	fmt.Printf("%s: %s", dealPlayer.GetName(), dealerHand)
	fmt.Printf(" (%d points)\n", dealerPoints.Total)
	dealerPoints.Print()

	game.AddPoints(dealer, dealerPoints.Total)
	if game.GameWon {
		game.CelebrateWinner(dealer)
		return
	}

	// Score dealer's crib
	cribPoints := crib.ScoreBreakdown(cut, true)
	fmt.Printf("%s (Crib): %s", dealPlayer.GetName(), crib)
	fmt.Printf(" (%d points)\n", cribPoints.Total)
	cribPoints.Print()

	game.AddPoints(dealer, cribPoints.Total)
	if game.GameWon {
		game.CelebrateWinner(dealer)
		return
	}

	fmt.Println()
	game.PrintPoints("SUMMARY (SHOW)", before0, before1)
	fmt.Println()
}

// Players try to place all of their cards on the pile
// Once the score goes above 31, start a new pile
func (game *Game) StartPegging() {
	dealer := game.Dealer
	players := game.Players
	linebreak := strings.Repeat("-", 30)

	state := PegState{
		Sum:      0,
		Turn:     1 - dealer, // pone places first card
		CardPile: make([]Card, 0),
	}

	fmt.Printf("(Pegging Pile 1)\n")
	for !EmptyHands(players) {
		//fmt.Printf("(Pegging Pile %d)\n", state.PileNum+1)
		// assume another skip if Player previously passed
		if state.Passed[state.Turn] {
			//fmt.Printf("%s says GO\n\n", players[state.Turn])
			state.Turn = 1 - state.Turn
			continue
		}

		fmt.Printf("Sum: %d\n", state.Sum)
		for _, c := range state.CardPile {
			fmt.Printf("%s ", c)
		}
		fmt.Println("[?]")

		card, passed := players[state.Turn].PlayPegCard(state)
		if passed {
			fmt.Printf("%s says GO", players[state.Turn])
			state.Passed[state.Turn] = true
		} else {
			fmt.Printf("%s plays %s", players[state.Turn], card)
			state.AddCard(card)
			points, comment := ScorePeggingPlay(&state, card)
			if points > 0 {
				fmt.Print(comment)
				game.AddPoints(state.Turn, points)
				if game.GameWon {
					game.CelebrateWinner(state.Turn)
					return
				}
			}
		}

		if state.ShouldReset() {
			// give points for last card (31 is included in ScorePeggingPlay)
			if state.Sum != 31 {
				fmt.Println()
				/*fmt.Printf("\nSum: %d\n", state.Sum)
				for _, c := range state.CardPile {
					fmt.Printf("%s ", c)
				}
				*/
				fmt.Printf("\n%s scores +1 [Last Card]", players[state.LastPlayer])
				game.AddPoints(state.LastPlayer, 1)
				if game.GameWon {
					game.CelebrateWinner(state.LastPlayer)
					return
				}
			}
			fmt.Printf("\n\n")
			state.Reset()
			if !EmptyHands(players) {
				fmt.Printf("(Pegging Pile %d)\n", state.PileNum+1)
			}
		} else {
			fmt.Printf("\n%s\n", linebreak)
		}

		state.Turn = 1 - state.Turn
	}

	//fmt.Printf("\nSum: %d\n", state.Sum)
	/*for _, c := range state.CardPile {
		fmt.Printf("%s ", c)
	}
	*/
	fmt.Println(state.CardPile)
	fmt.Printf("\nAll cards have been played!\n")

	if state.Sum != 0 {
		// the loop ended after both hands are empty
		// sum can be zero after 31, or if both Players Go
		fmt.Printf("%s scores +1 [Last Card]\n\n", players[state.LastPlayer])
		game.AddPoints(state.LastPlayer, 1)
		if game.GameWon {
			game.CelebrateWinner(state.LastPlayer)
			return
		}
	}
}

// ------------------------------------------------------------ //

func NewComputerGame() *Game {
	p1 := &ComputerPlayer{
		Name:   "COM 1",
		Points: 0,
	}

	p2 := &ComputerPlayer{
		Name:   "COM 2",
		Points: 0,
	}

	return &Game{
		Deck:    NewDeck(),
		Players: [2]Player{p1, p2},
		Dealer:  0,
	}
}

func NewPlayerGame() *Game {
	p1 := &ComputerPlayer{
		Name:   "COM 1",
		Points: 0,
	}

	var name string
	fmt.Print("Please provide your name: ")
	fmt.Scanln(&name)
	p2 := &HumanPlayer{
		Name:   name,
		Points: 0,
	}

	return &Game{
		Deck:    NewDeck(),
		Players: [2]Player{p1, p2},
		Dealer:  0,
	}
}

func Start() {

	AwesomeTitle := `
  ___                                         
 / _ \                                        
/ /_\ \_      _____  ___  ___  _ __ ___   ___ 
|  _  \ \ /\ / / _ \/ __|/ _ \| '_ ' _ \ / _ \
| | | |\ V  V /  __/\__ \ (_) | | | | | |  __/
\_| |_/ \_/\_/ \___||___/\___/|_| |_| |_|\___|

 _____      _ _     _                         
/  __ \    (_) |   | |                        
| /  \/_ __ _| |__ | |__   __ _  __ _  ___    
| |   | '__| | '_ \| '_ \ / _' |/ _' |/ _ \   
| \__/\ |  | | |_) | |_) | (_| | (_| |  __/   
 \____/_|  |_|_.__/|_.__/ \__,_|\__, |\___|   
                                 __/ |        
                                |___/         
 _____                                        
|  __ \                                       
| |  \/ __ _ _ __ ___   ___                   
| | __ / _' | '_ ' _ \ / _ \                  
| |_\ \ (_| | | | | | |  __/                  
 \____/\__,_|_| |_| |_|\___|  v1
`
	fmt.Println(AwesomeTitle)

	game := NewComputerGame()
	//game := NewPlayerGame()

	fmt.Printf("Welcome %s and %s!\n", game.Players[0], game.Players[1])
	fmt.Printf("A new game is beginning...\n\n")
	game.StartGame()
}
